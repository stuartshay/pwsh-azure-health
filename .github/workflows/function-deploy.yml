name: Deploy Function App

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - prod
        default: 'dev'
  push:
    branches:
      - master
    paths:
      - 'src/**'
      - '.github/workflows/function-deploy.yml'

permissions:
  contents: read
  id-token: write

env:
  MAX_RETRY_ATTEMPTS: 5
  RETRY_BASE_DELAY: 2
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './src'

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'dev' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set environment variables
        run: |
          ENV_NAME="${{ github.event.inputs.environment || 'dev' }}"
          echo "ENVIRONMENT=$ENV_NAME" >> "$GITHUB_ENV"
          echo "RESOURCE_GROUP=rg-azure-health-$ENV_NAME" >> "$GITHUB_ENV"

      - name: Setup retry utilities
        shell: bash
        run: |
          # Create retry function for Azure operations
          cat > /tmp/retry-utils.sh << 'RETRY_EOF'
          #!/bin/bash

          # Retry function with exponential backoff for Azure operations
          # Usage: retry_azure_operation <max_attempts> <description> <command...>
          retry_azure_operation() {
            local max_attempts=$1
            shift
            local description=$1
            shift
            local command=("$@")

            local attempt=1
            local delay=$RETRY_BASE_DELAY
            local max_delay=32

            echo "ðŸ”„ Starting: $description" >&2

            while [ $attempt -le $max_attempts ]; do
              echo "  Attempt $attempt/$max_attempts..." >&2

              # Execute command and capture output
              local output
              local exit_code

              set +e  # Temporarily disable exit on error
              output=$("${command[@]}" 2>&1)
              exit_code=$?
              set -e

              # Success
              if [ $exit_code -eq 0 ]; then
                echo "$output"
                echo "âœ… Success: $description" >&2
                return 0
              fi

              # Check for permanent failures (don't retry)
              if echo "$output" | grep -qE \
                "(AuthorizationFailed|InvalidAuthenticationToken|Forbidden|ResourceNotFound)"; then
                echo "âŒ Permanent failure detected: $description" >&2
                echo "$output" >&2
                return $exit_code
              fi

              # Last attempt failed
              if [ $attempt -eq $max_attempts ]; then
                echo "âŒ Failed after $max_attempts attempts: $description" >&2
                echo "$output" >&2
                return $exit_code
              fi

              # Check if it's a known transient error
              local error_type="Unknown error"
              if echo "$output" | grep -qE "TooManyRequests|429"; then
                error_type="Rate limit (429)"
              elif echo "$output" | grep -qE "ServiceUnavailable|503"; then
                error_type="Service unavailable (503)"
              elif echo "$output" | grep -qE "GatewayTimeout|504"; then
                error_type="Gateway timeout (504)"
              elif echo "$output" | grep -qE "InternalServerError|500"; then
                error_type="Internal server error (500)"
              elif echo "$output" | grep -qE "Conflict|409"; then
                error_type="Conflict (409)"
              fi

              echo "âš ï¸  $error_type - Retrying in ${delay}s..." >&2
              echo "    Error preview: $(echo "$output" | head -n 1)" >&2

              sleep $delay

              # Exponential backoff with cap
              if [ $delay -lt $max_delay ]; then
                delay=$((delay * 2))
              fi

              attempt=$((attempt + 1))
            done
          }
          RETRY_EOF

          chmod +x /tmp/retry-utils.sh
          echo "âœ… Retry utilities configured"

      - name: Get Function App name
        id: get-function-app
        shell: bash
        run: |
          source /tmp/retry-utils.sh

          echo "ðŸ” Getting Function App name from resource group..."

          # Get function app name with retry
          function_app_json=$(retry_azure_operation \
            "$MAX_RETRY_ATTEMPTS" \
            "Get Function App name" \
            az functionapp list \
              --resource-group "$RESOURCE_GROUP" \
              --query "[0].{name:name,state:state}" \
              --output json)

          function_app_name=$(echo "$function_app_json" | jq -r '.name')
          function_app_state=$(echo "$function_app_json" | jq -r '.state')

          if [ -z "$function_app_name" ] || [ "$function_app_name" = "null" ]; then
            echo "âŒ No Function App found in resource group: $RESOURCE_GROUP"
            exit 1
          fi

          echo "âœ… Found Function App: $function_app_name (state: $function_app_state)"
          echo "function_app_name=$function_app_name" >> "$GITHUB_OUTPUT"

      - name: Prepare deployment package
        shell: bash
        run: |
          echo "ðŸ“¦ Preparing Function App deployment package..."

          cd "$AZURE_FUNCTIONAPP_PACKAGE_PATH"

          # Verify required files exist
          if [ ! -f "host.json" ]; then
            echo "âŒ host.json not found in $AZURE_FUNCTIONAPP_PACKAGE_PATH"
            exit 1
          fi

          if [ ! -f "requirements.psd1" ]; then
            echo "âŒ requirements.psd1 not found in $AZURE_FUNCTIONAPP_PACKAGE_PATH"
            exit 1
          fi

          # Count function directories
          function_count=$(find . -maxdepth 1 -type d -name "Get*" | wc -l)
          echo "ðŸ“Š Found $function_count function(s)"

          # List functions
          echo "Functions to deploy:"
          find . -maxdepth 1 -type d -name "Get*" -exec basename {} \;

          echo "âœ… Package prepared successfully"

      - name: Deploy to Function App
        id: deploy
        shell: bash
        run: |
          source /tmp/retry-utils.sh

          FUNCTION_APP_NAME="${{ steps.get-function-app.outputs.function_app_name }}"

          echo "ðŸš€ Deploying Function App code to $FUNCTION_APP_NAME..."
          echo "   Environment: $ENVIRONMENT"
          echo "   Source: $AZURE_FUNCTIONAPP_PACKAGE_PATH"

          # Create zip package
          cd "$AZURE_FUNCTIONAPP_PACKAGE_PATH"
          zip -r ../function-app.zip . -x "*.git*" -x "*local.settings.json" -x "*.azurite/*"

          # Deploy using zip deploy with retry
          retry_azure_operation \
            "$MAX_RETRY_ATTEMPTS" \
            "Deploy Function App" \
            az functionapp deployment source config-zip \
              --resource-group "$RESOURCE_GROUP" \
              --name "$FUNCTION_APP_NAME" \
              --src ../function-app.zip \
              --output none

          echo "âœ… Deployment completed successfully!"

      - name: Verify deployment
        id: verify-deployment
        shell: bash
        run: |
          source /tmp/retry-utils.sh

          FUNCTION_APP_NAME="${{ steps.get-function-app.outputs.function_app_name }}"

          echo "ðŸ” Verifying Function App deployment..."

          # Get function app details with retry
          app_info=$(retry_azure_operation \
            "$MAX_RETRY_ATTEMPTS" \
            "Get Function App details" \
            az functionapp show \
              --resource-group "$RESOURCE_GROUP" \
              --name "$FUNCTION_APP_NAME" \
              --output json)

          app_state=$(echo "$app_info" | jq -r '.state')
          default_hostname=$(echo "$app_info" | jq -r '.defaultHostName')

          echo "âœ… Function App verified"
          echo "   Name: $FUNCTION_APP_NAME"
          echo "   State: $app_state"
          echo "   URL: https://$default_hostname"

          # Export for use in subsequent steps
          echo "function_url=https://$default_hostname" >> "$GITHUB_OUTPUT"

          # List deployed functions
          echo ""
          echo "ðŸ“‹ Deployed functions:"
          retry_azure_operation \
            "$MAX_RETRY_ATTEMPTS" \
            "List functions" \
            az functionapp function list \
              --resource-group "$RESOURCE_GROUP" \
              --name "$FUNCTION_APP_NAME" \
              --query "[].{Name:name,Status:config.disabled}" \
              --output table || echo "âš ï¸  Unable to list functions (they may still be initializing)"

          # Generate deployment summary
          {
            echo "### Function App Deployment Summary"
            echo ""
            echo "**Environment:** $ENVIRONMENT"
            echo "**Resource Group:** $RESOURCE_GROUP"
            echo "**Function App:** $FUNCTION_APP_NAME"
            echo "**State:** $app_state"
            echo "**URL:** https://$default_hostname"
            echo ""
            echo "âœ… Deployment completed successfully!"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Verify Function App Health with Azure CLI
        id: health-check
        shell: bash
        run: |
          source /tmp/retry-utils.sh

          FUNCTION_APP_NAME="${{ steps.get-function-app.outputs.function_app_name }}"
          FUNCTION_URL="${{ steps.verify-deployment.outputs.function_url }}"
          HEALTH_ENDPOINT="${FUNCTION_URL}/api/health"

          echo "ðŸ¥ Performing health check on Function App..."
          echo "   Function App: $FUNCTION_APP_NAME"
          echo "   Health Endpoint: $HEALTH_ENDPOINT"

          # Wait for function app to be ready using Azure CLI
          echo "â³ Waiting for Function App to be ready (up to 5 minutes)..."

          max_attempts=30
          attempt=1
          sleep_interval=10

          while [ $attempt -le $max_attempts ]; do
            echo "  Attempt $attempt/$max_attempts..."

            # Check function app state via Azure CLI
            app_state=$(retry_azure_operation \
              "$MAX_RETRY_ATTEMPTS" \
              "Get Function App state" \
              az functionapp show \
                --resource-group "$RESOURCE_GROUP" \
                --name "$FUNCTION_APP_NAME" \
                --query "state" \
                --output tsv 2>/dev/null || echo "Unknown")

            if [ "$app_state" = "Running" ]; then
              echo "âœ… Function App is in Running state"

              # Try to call the health endpoint
              echo "ðŸ” Testing health endpoint..."

              # Use curl with timeout to test the endpoint
              if response=$(curl -f -s -m 10 "$HEALTH_ENDPOINT" 2>&1); then
                echo "âœ… Health endpoint responded successfully"
                echo "$response" | jq '.' 2>/dev/null || echo "$response"

                # Parse health status if JSON
                health_status=$(echo "$response" | jq -r '.status' 2>/dev/null || echo "unknown")

                if [ "$health_status" = "healthy" ]; then
                  echo "âœ… Function App health check passed!"
                  echo "health_status=healthy" >> "$GITHUB_OUTPUT"
                  echo "health_endpoint=$HEALTH_ENDPOINT" >> "$GITHUB_OUTPUT"
                  break
                else
                  echo "âš ï¸  Health status: $health_status"
                fi
              else
                echo "âš ï¸  Health endpoint not yet accessible: $response"
              fi
            else
              echo "â³ Function App state: $app_state"
            fi

            if [ $attempt -eq $max_attempts ]; then
              echo "âŒ Health check failed after $max_attempts attempts"
              echo "   This may indicate a deployment issue or slow startup"
              exit 1
            fi

            echo "   Waiting ${sleep_interval}s before next attempt..."
            sleep $sleep_interval
            attempt=$((attempt + 1))
          done

          {
            echo "### Health Check Results"
            echo "âœ… Function App health check passed"
            echo "- **Function App:** $FUNCTION_APP_NAME"
            echo "- **Health Endpoint:** $HEALTH_ENDPOINT"
            echo "- **Status:** healthy"
            echo "- **Verification Method:** Azure CLI + HTTP health endpoint"
          } >> "$GITHUB_STEP_SUMMARY"
